name: Certify Verification Results

on:
  push:
    branches:
      - main
    paths:
      - 'src/**/*.rs'
      - 'Cargo.toml'
  workflow_dispatch:

permissions:
  contents: write  # Needed to commit certifications.json

jobs:
  # Extract Verus and Rust versions from Cargo.toml metadata
  get-versions:
    name: Get Verus and Rust Version
    runs-on: ubuntu-latest
    outputs:
      verus_version: ${{ steps.extract.outputs.version }}
      rust_version: ${{ steps.extract.outputs.rust_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          sparse-checkout: Cargo.toml
          sparse-checkout-cone-mode: false
      
      - name: Extract versions from Cargo.toml
        id: extract
        run: |
          METADATA=$(awk '/^\[package.metadata.verus\]/{flag=1;next}/^\[.*\]/{flag=0}flag' Cargo.toml)
          
          VERSION=$(echo "$METADATA" | grep -E '^\s*release\s*=' | sed 's/.*= *"\([^"]*\)".*/\1/' | head -1)
          RUST_VERSION=$(echo "$METADATA" | grep -E '^\s*rust-version\s*=' | sed 's/.*= *"\([^"]*\)".*/\1/' | head -1)
          
          if [ -n "$VERSION" ]; then
            echo "Found Verus release version: $VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          else
            echo "::error::No Verus release version found in Cargo.toml"
            exit 1
          fi
          
          if [ -n "$RUST_VERSION" ]; then
            echo "Found Rust version: $RUST_VERSION"
            echo "rust_version=$RUST_VERSION" >> $GITHUB_OUTPUT
          else
            echo "::error::No Rust version found in Cargo.toml"
            exit 1
          fi

  verify-and-certify:
    name: Run Verification & Certify On-Chain
    needs: get-versions
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ needs.get-versions.outputs.rust_version }}

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cargo/bin
          key: ${{ runner.os }}-cargo-certify-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-certify-
            ${{ runner.os }}-cargo-

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Install verus-analyzer
        run: |
          VERUS_URL=$(curl -s https://api.github.com/repos/verus-lang/verus-analyzer/releases/latest | jq -r '.assets[] | select(.name == "verus-analyzer-x86_64-unknown-linux-gnu.gz") | .browser_download_url')
          if [ -z "$VERUS_URL" ] || [ "$VERUS_URL" = "null" ]; then
            echo "Error: Failed to determine verus-analyzer download URL from GitHub API." >&2
            exit 1
          fi
          if ! wget "$VERUS_URL" -O verus-analyzer.gz; then
            echo "Error: Downloading verus-analyzer from $VERUS_URL failed." >&2
            exit 1
          fi
          gunzip verus-analyzer.gz
          chmod +x verus-analyzer
          sudo mv verus-analyzer /usr/local/bin/
          verus-analyzer --version

      - name: Install Verus
        env:
          VERUS_VERSION: ${{ needs.get-versions.outputs.verus_version }}
        run: |
          echo "Installing Verus version: $VERUS_VERSION"
          VERUS_URL="https://github.com/verus-lang/verus/releases/download/release%2F${VERUS_VERSION}/verus-${VERUS_VERSION}-x86-linux.zip"
          
          if [ -x ~/.cargo/bin/verus-x86-linux/verus ]; then
            CACHED_VERSION=$(~/.cargo/bin/verus-x86-linux/verus --version 2>/dev/null | head -1 || echo "unknown")
            if echo "$CACHED_VERSION" | grep -q "$VERUS_VERSION"; then
              echo "Verus $VERUS_VERSION already installed (from cache)"
            else
              echo "Cached Verus version mismatch, reinstalling..."
              rm -rf ~/.cargo/bin/verus-x86-linux
            fi
          fi
          
          if [ ! -x ~/.cargo/bin/verus-x86-linux/verus ]; then
            echo "Downloading Verus from: $VERUS_URL"
            wget "$VERUS_URL" -O verus.zip
            unzip verus.zip
            mv verus-x86-linux ~/.cargo/bin
            cd ~/.cargo/bin
            ln -sf verus-x86-linux/cargo-verus
            echo "Verus $VERUS_VERSION installed"
          fi

      - name: Install scip CLI
        run: |
          SCIP_URL=$(curl -s https://api.github.com/repos/sourcegraph/scip/releases/latest | jq -r '.assets[] | select(.name == "scip-linux-amd64.tar.gz") | .browser_download_url')
          if [ -z "$SCIP_URL" ] || [ "$SCIP_URL" = "null" ]; then
            echo "Error: Failed to determine SCIP download URL from GitHub API." >&2
            exit 1
          fi
          wget "$SCIP_URL" -O scip-linux.tar.gz
          tar -xzf scip-linux.tar.gz
          chmod +x scip
          sudo mv scip /usr/local/bin/
          scip --version

      - name: Install probe-verus
        run: |
          cargo install --force --git https://github.com/Beneficial-AI-Foundation/probe-verus

      - name: Run probe-verus atomize
        run: |
          echo "=== Running probe-verus atomize ==="
          echo "Working directory: $(pwd)"
          
          probe-verus atomize . -o atoms.json
          
          echo ""
          echo "=== Generated atoms.json ==="
          ls -la atoms.json
          echo "Number of entries: $(jq 'length' atoms.json)"

      - name: Run probe-verus verify
        id: verify
        run: |
          echo "=== Running probe-verus verify ==="
          
          probe-verus verify . \
            -p pmemlog \
            -o results.json \
            -a atoms.json
          
          echo ""
          echo "=== Generated results.json ==="
          ls -la results.json
          
          echo "results_file=$PWD/results.json" >> $GITHUB_OUTPUT
          
          echo "=== Verification Results Summary ==="
          cat results.json | jq '.summary'

      - name: Upload verification results artifact
        uses: actions/upload-artifact@v4
        with:
          name: verification-results
          path: results.json
          retention-days: 90

      # --- Certification Setup ---
      
      - name: Checkout eth_certify
        uses: actions/checkout@v4
        with:
          repository: Beneficial-AI-Foundation/eth_certify
          token: ${{ secrets.CERTIFY_REPO_PAT }}
          path: certify
          submodules: recursive

      - name: Install Python and uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Install certify dependencies
        working-directory: certify
        run: |
          uv sync

      - name: Create certify.conf for verification results
        working-directory: certify
        env:
          RESULTS_FILE: ${{ steps.verify.outputs.results_file }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          echo "# Auto-generated for CI certification" > certify.conf
          echo "CERTIFY_SOURCE=\"${RESULTS_FILE}\"" >> certify.conf
          echo "CERTIFY_DESCRIPTION=\"pmemlog Verus Verification Results - Commit ${COMMIT_SHA}\"" >> certify.conf
          
          echo "=== certify.conf ==="
          cat certify.conf

      # --- Certification to Ethereum Mainnet via Gnosis Safe ---

      - name: Certify verification results on Mainnet (via Safe)
        id: certify_mainnet
        working-directory: certify
        env:
          MAINNET_RPC_URL: ${{ secrets.MAINNET_RPC_URL }}
          MAINNET_PRIVATE_KEY: ${{ secrets.MAINNET_PRIVATE_KEY }}
          CERTIFY_ADDRESS: ${{ vars.MAINNET_CERTIFIER_ADDRESS }}
          SAFE_ADDRESS: ${{ vars.MAINNET_SAFE_ADDRESS }}
        run: |
          echo "Certifying verification results hash on Ethereum Mainnet via Gnosis Safe..."
          
          # Strip any whitespace/newlines from the address
          SAFE_ADDRESS_CLEAN=$(echo "$SAFE_ADDRESS" | tr -d '[:space:]')
          echo "Using Safe address: $SAFE_ADDRESS_CLEAN"
          
          set +e
          OUTPUT=$(uv run python3 -m certify_cli certify --network mainnet --safe "$SAFE_ADDRESS_CLEAN" --execute 2>/tmp/certify_mainnet_stderr.log)
          EXIT_CODE=$?
          set -e
          
          echo "$OUTPUT"
          
          if [ $EXIT_CODE -ne 0 ] && [ -f /tmp/certify_mainnet_stderr.log ]; then
            echo "Certification command exited with code $EXIT_CODE"
            echo "Filtered error output (excluding potentially sensitive lines):"
            grep -vi -E '(key|secret|password|token|private)' /tmp/certify_mainnet_stderr.log || echo "(no safe error lines to display)"
          fi
          
          # Match tx hash with or without 0x prefix
          TX_HASH=$(echo "$OUTPUT" | grep -Eo 'Tx Hash:[[:space:]]*(0x)?[a-fA-F0-9]{64}' | head -1 | grep -Eo '[a-fA-F0-9]{64}$')
          CONTENT_HASH=$(echo "$OUTPUT" | grep -Eo 'Content Hash:[[:space:]]*0x[0-9a-fA-F]+' | head -1 | sed -E 's/.*(0x[0-9a-fA-F]+)/\1/')
          
          if [ -n "$TX_HASH" ]; then
            echo "tx_hash=0x${TX_HASH}" >> $GITHUB_OUTPUT
            echo "etherscan_url=https://etherscan.io/tx/0x${TX_HASH}" >> $GITHUB_OUTPUT
            echo "Captured Mainnet Tx Hash: 0x${TX_HASH}"
          else
            echo "tx_hash=" >> $GITHUB_OUTPUT
            echo "etherscan_url=" >> $GITHUB_OUTPUT
            echo "::error::Could not extract transaction hash from output"
            exit 1
          fi
          
          if [ -n "$CONTENT_HASH" ]; then
            echo "content_hash=${CONTENT_HASH}" >> $GITHUB_OUTPUT
          fi
          
          echo ""
          echo "Verification results certified on Ethereum Mainnet!"
          echo "View events: https://etherscan.io/address/${{ vars.MAINNET_CERTIFIER_ADDRESS }}#events"

      # --- Update Certifications History ---

      - name: Update certifications.json
        env:
          TX_HASH: ${{ steps.certify_mainnet.outputs.tx_hash }}
          ETHERSCAN_URL: ${{ steps.certify_mainnet.outputs.etherscan_url }}
          CONTENT_HASH: ${{ steps.certify_mainnet.outputs.content_hash }}
          RESULTS_FILE: ${{ steps.verify.outputs.results_file }}
        run: |
          ARTIFACT_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          if [ -n "$RESULTS_FILE" ] && [ -f "$RESULTS_FILE" ]; then
            # When using -a atoms.json, output is a dictionary of functions
            # Try new format first (count functions), fall back to old format with .summary
            if jq -e 'type == "object" and (keys | length) > 0 and (.[keys[0]] | has("status"))' "$RESULTS_FILE" > /dev/null 2>&1; then
              # New format: dictionary keyed by function name
              TOTAL_FUNCTIONS=$(jq 'keys | length' "$RESULTS_FILE") || TOTAL_FUNCTIONS=0
              VERIFIED_COUNT=$(jq '[.[] | select(.status == "verified")] | length' "$RESULTS_FILE") || VERIFIED_COUNT=0
              echo "Parsed new format: $VERIFIED_COUNT verified out of $TOTAL_FUNCTIONS total"
            elif jq -e '.summary' "$RESULTS_FILE" > /dev/null 2>&1; then
              # Old format with .summary
              VERIFIED_COUNT=$(jq -r '.summary.verified_functions // 0' "$RESULTS_FILE") || VERIFIED_COUNT=0
              TOTAL_FUNCTIONS=$(jq -r '.summary.total_functions // 0' "$RESULTS_FILE") || TOTAL_FUNCTIONS=0
              echo "Parsed old format: $VERIFIED_COUNT verified out of $TOTAL_FUNCTIONS total"
            else
              echo "WARNING: Could not parse results.json format"
              VERIFIED_COUNT=0
              TOTAL_FUNCTIONS=0
            fi
          else
            echo "WARNING: RESULTS_FILE not found; defaulting verification summary counts to 0."
            VERIFIED_COUNT=0
            TOTAL_FUNCTIONS=0
          fi
          
          NEW_ENTRY=$(jq -n \
            --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --arg commit_sha "${{ github.sha }}" \
            --arg commit_short "$(echo '${{ github.sha }}' | cut -c1-7)" \
            --arg artifact_url "$ARTIFACT_URL" \
            --arg content_hash "${CONTENT_HASH:-}" \
            --arg tx_hash "${TX_HASH:-}" \
            --arg etherscan_url "${ETHERSCAN_URL:-}" \
            --argjson verified_count "${VERIFIED_COUNT:-0}" \
            --argjson total_functions "${TOTAL_FUNCTIONS:-0}" \
            '{
              timestamp: $timestamp,
              commit_sha: $commit_sha,
              commit_short: $commit_short,
              artifact_url: $artifact_url,
              content_hash: $content_hash,
              mainnet_tx: $tx_hash,
              mainnet_etherscan: $etherscan_url,
              verified_count: $verified_count,
              total_functions: $total_functions
            }')
          
          CERT_FILE="docs/certifications.json"
          if [ -f "$CERT_FILE" ]; then
            jq --argjson new "$NEW_ENTRY" '.certifications = [$new] + .certifications' "$CERT_FILE" > tmp.json
            mv tmp.json "$CERT_FILE"
          else
            mkdir -p docs
            jq -n --argjson entry "$NEW_ENTRY" '{ certifications: [$entry] }' > "$CERT_FILE"
          fi
          
          echo "=== Updated certifications.json ==="
          cat "$CERT_FILE" | jq '.'

      - name: Commit certifications.json
        env:
          TX_HASH: ${{ steps.certify_mainnet.outputs.tx_hash }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add docs/certifications.json
          
          if git diff --cached --quiet; then
            echo "::error::No changes to certifications.json despite successful certification. This is unexpected."
            exit 1
          fi
          
          git commit -m "chore: update certifications.json with tx ${TX_HASH}"
          git push
          echo "Committed and pushed certifications.json update"

